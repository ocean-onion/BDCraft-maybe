package com.bdcraft.plugin.modules.vital.modules.message;

import com.bdcraft.plugin.BDCraft;
import com.bdcraft.plugin.config.ConfigType;
import com.bdcraft.plugin.modules.perms.BDPermissionAPI;
import com.bdcraft.plugin.modules.perms.PermNode;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Sound;
import org.bukkit.command.CommandSender;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.scheduler.BukkitRunnable;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Comprehensive manager for player-to-player messaging and social features.
 */
public class MessageManager {
    private final BDCraft plugin;
    private final Logger logger;
    private BDPermissionAPI permissionAPI;
    
    // Message history
    private final Map<UUID, UUID> lastMessaged = new ConcurrentHashMap<>();
    private final Map<UUID, List<MessageEntry>> messageHistory = new ConcurrentHashMap<>();
    
    // Social features
    private final Map<UUID, Set<UUID>> ignoredPlayers = new ConcurrentHashMap<>();
    private final Map<UUID, Boolean> socialSpy = new ConcurrentHashMap<>();
    private final Set<UUID> messagingDisabled = new HashSet<>();
    private final Map<UUID, Long> messageCooldowns = new ConcurrentHashMap<>();
    
    // Message formatting
    private String privateMessageFormatSender;
    private String privateMessageFormatReceiver;
    private String socialSpyFormat;
    private String consoleMessageFormat;
    
    // Configuration
    private boolean enableMessageSound;
    private Sound messageSound;
    private float messageSoundVolume;
    private float messageSoundPitch;
    private boolean enableSocialSpy;
    private boolean enableMessageCooldown;
    private int messageCooldownSeconds;
    private boolean enableMessageLogging;
    private boolean enableMessageFilter;
    private List<String> filteredWords;
    private String messageFilterReplacement;
    private int maxMessageHistory;
    private boolean allowFormattingCodes;
    
    /**
     * Creates a new MessageManager.
     *
     * @param plugin The plugin instance
     */
    public MessageManager(BDCraft plugin) {
        this.plugin = plugin;
        this.logger = plugin.getLogger();
        // Uncomment when PermissionAPI is available
        // this.permissionAPI = plugin.getPermissionAPI();
        loadConfiguration();
        loadPlayerData();
        startSaveTask();
    }
    
    /**
     * Loads configuration settings for messaging.
     */
    private void loadConfiguration() {
        File messageConfig = new File(plugin.getDataFolder(), "message.yml");
        FileConfiguration config;
        
        // Create default config if it doesn't exist
        if (!messageConfig.exists()) {
            try {
                messageConfig.getParentFile().mkdirs();
                messageConfig.createNewFile();
                config = YamlConfiguration.loadConfiguration(messageConfig);
                
                // Message formats
                config.set("format.sender", "&7[&cme &7→ &c{recipient}&7] &f{message}");
                config.set("format.receiver", "&7[&c{sender} &7→ &cme&7] &f{message}");
                config.set("format.social_spy", "&8[&7SocialSpy&8] &7{sender} &8→ &7{recipient}&8: &f{message}");
                config.set("format.console", "&7[&cCONSOLE &7→ &c{recipient}&7] &f{message}");
                
                // Sound settings
                config.set("sound.enabled", true);
                config.set("sound.name", "ENTITY_EXPERIENCE_ORB_PICKUP");
                config.set("sound.volume", 1.0f);
                config.set("sound.pitch", 1.0f);
                
                // General settings
                config.set("social_spy.enabled", true);
                config.set("cooldown.enabled", true);
                config.set("cooldown.seconds", 3);
                config.set("logging.enabled", true);
                config.set("formatting_codes.allowed", false);
                
                // Message history
                config.set("history.max_messages", 100);
                
                // Message filter
                config.set("filter.enabled", true);
                List<String> defaultFilteredWords = new ArrayList<>();
                defaultFilteredWords.add("badword1");
                defaultFilteredWords.add("badword2");
                config.set("filter.words", defaultFilteredWords);
                config.set("filter.replacement", "****");
                
                config.save(messageConfig);
            } catch (IOException e) {
                logger.log(Level.SEVERE, "Could not create default message.yml", e);
                // Use default values
                privateMessageFormatSender = "&7[&cme &7→ &c{recipient}&7] &f{message}";
                privateMessageFormatReceiver = "&7[&c{sender} &7→ &cme&7] &f{message}";
                socialSpyFormat = "&8[&7SocialSpy&8] &7{sender} &8→ &7{recipient}&8: &f{message}";
                consoleMessageFormat = "&7[&cCONSOLE &7→ &c{recipient}&7] &f{message}";
                enableMessageSound = true;
                messageSound = Sound.ENTITY_EXPERIENCE_ORB_PICKUP;
                messageSoundVolume = 1.0f;
                messageSoundPitch = 1.0f;
                enableSocialSpy = true;
                enableMessageCooldown = true;
                messageCooldownSeconds = 3;
                enableMessageLogging = true;
                enableMessageFilter = true;
                filteredWords = new ArrayList<>();
                filteredWords.add("badword1");
                filteredWords.add("badword2");
                messageFilterReplacement = "****";
                maxMessageHistory = 100;
                allowFormattingCodes = false;
                return;
            }
        } else {
            config = YamlConfiguration.loadConfiguration(messageConfig);
        }
        
        // Load settings
        privateMessageFormatSender = config.getString("format.sender", "&7[&cme &7→ &c{recipient}&7] &f{message}");
        privateMessageFormatReceiver = config.getString("format.receiver", "&7[&c{sender} &7→ &cme&7] &f{message}");
        socialSpyFormat = config.getString("format.social_spy", "&8[&7SocialSpy&8] &7{sender} &8→ &7{recipient}&8: &f{message}");
        consoleMessageFormat = config.getString("format.console", "&7[&cCONSOLE &7→ &c{recipient}&7] &f{message}");
        
        enableMessageSound = config.getBoolean("sound.enabled", true);
        try {
            messageSound = Sound.valueOf(config.getString("sound.name", "ENTITY_EXPERIENCE_ORB_PICKUP"));
        } catch (IllegalArgumentException e) {
            messageSound = Sound.ENTITY_EXPERIENCE_ORB_PICKUP;
            logger.warning("Invalid sound name in message.yml. Using default sound.");
        }
        messageSoundVolume = (float) config.getDouble("sound.volume", 1.0);
        messageSoundPitch = (float) config.getDouble("sound.pitch", 1.0);
        
        enableSocialSpy = config.getBoolean("social_spy.enabled", true);
        enableMessageCooldown = config.getBoolean("cooldown.enabled", true);
        messageCooldownSeconds = config.getInt("cooldown.seconds", 3);
        enableMessageLogging = config.getBoolean("logging.enabled", true);
        allowFormattingCodes = config.getBoolean("formatting_codes.allowed", false);
        
        maxMessageHistory = config.getInt("history.max_messages", 100);
        
        enableMessageFilter = config.getBoolean("filter.enabled", true);
        filteredWords = config.getStringList("filter.words");
        messageFilterReplacement = config.getString("filter.replacement", "****");
        
        logger.info("Loaded message configuration");
    }
    
    /**
     * Loads player data from storage.
     */
    private void loadPlayerData() {
        File dataFile = new File(plugin.getDataFolder(), "messagedata.yml");
        if (!dataFile.exists()) {
            return;
        }
        
        FileConfiguration data = YamlConfiguration.loadConfiguration(dataFile);
        
        // Load ignored players
        ConfigurationSection ignoredSection = data.getConfigurationSection("ignored");
        if (ignoredSection != null) {
            for (String playerUuidStr : ignoredSection.getKeys(false)) {
                try {
                    UUID playerUuid = UUID.fromString(playerUuidStr);
                    List<String> ignoredUuidStrs = ignoredSection.getStringList(playerUuidStr);
                    Set<UUID> ignored = new HashSet<>();
                    
                    for (String ignoredUuidStr : ignoredUuidStrs) {
                        try {
                            ignored.add(UUID.fromString(ignoredUuidStr));
                        } catch (IllegalArgumentException e) {
                            logger.warning("Invalid UUID in ignored players list: " + ignoredUuidStr);
                        }
                    }
                    
                    if (!ignored.isEmpty()) {
                        ignoredPlayers.put(playerUuid, ignored);
                    }
                } catch (IllegalArgumentException e) {
                    logger.warning("Invalid player UUID in messagedata.yml: " + playerUuidStr);
                }
            }
        }
        
        // Load social spy status
        ConfigurationSection socialSpySection = data.getConfigurationSection("socialspy");
        if (socialSpySection != null) {
            for (String playerUuidStr : socialSpySection.getKeys(false)) {
                try {
                    UUID playerUuid = UUID.fromString(playerUuidStr);
                    boolean enabled = socialSpySection.getBoolean(playerUuidStr);
                    socialSpy.put(playerUuid, enabled);
                } catch (IllegalArgumentException e) {
                    logger.warning("Invalid player UUID in messagedata.yml: " + playerUuidStr);
                }
            }
        }
        
        // Load messaging disabled status
        List<String> disabledList = data.getStringList("messaging_disabled");
        for (String playerUuidStr : disabledList) {
            try {
                messagingDisabled.add(UUID.fromString(playerUuidStr));
            } catch (IllegalArgumentException e) {
                logger.warning("Invalid player UUID in messagedata.yml: " + playerUuidStr);
            }
        }
        
        logger.info("Loaded message player data");
    }
    
    /**
     * Saves player data to storage.
     */
    public void savePlayerData() {
        File dataFile = new File(plugin.getDataFolder(), "messagedata.yml");
        FileConfiguration data = new YamlConfiguration();
        
        // Save ignored players
        ConfigurationSection ignoredSection = data.createSection("ignored");
        for (Map.Entry<UUID, Set<UUID>> entry : ignoredPlayers.entrySet()) {
            UUID playerUuid = entry.getKey();
            Set<UUID> ignored = entry.getValue();
            
            List<String> ignoredUuidStrs = new ArrayList<>();
            for (UUID ignoredUuid : ignored) {
                ignoredUuidStrs.add(ignoredUuid.toString());
            }
            
            ignoredSection.set(playerUuid.toString(), ignoredUuidStrs);
        }
        
        // Save social spy status
        ConfigurationSection socialSpySection = data.createSection("socialspy");
        for (Map.Entry<UUID, Boolean> entry : socialSpy.entrySet()) {
            UUID playerUuid = entry.getKey();
            boolean enabled = entry.getValue();
            socialSpySection.set(playerUuid.toString(), enabled);
        }
        
        // Save messaging disabled status
        List<String> disabledList = new ArrayList<>();
        for (UUID playerUuid : messagingDisabled) {
            disabledList.add(playerUuid.toString());
        }
        data.set("messaging_disabled", disabledList);
        
        try {
            data.save(dataFile);
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Could not save message player data", e);
        }
    }
    
    /**
     * Starts a task to periodically save player data.
     */
    private void startSaveTask() {
        new BukkitRunnable() {
            @Override
            public void run() {
                savePlayerData();
            }
        }.runTaskTimer(plugin, 6000L, 6000L); // Save every 5 minutes
    }
    
    /**
     * Sends a private message from one player to another.
     *
     * @param sender The sender
     * @param recipient The recipient
     * @param message The message
     * @return true if the message was sent, false otherwise
     */
    public boolean sendMessage(Player sender, Player recipient, String message) {
        if (sender == null || recipient == null || !recipient.isOnline() || message == null || message.isEmpty()) {
            return false;
        }
        
        UUID senderUuid = sender.getUniqueId();
        UUID recipientUuid = recipient.getUniqueId();
        
        // Format the message for both sender and recipient
        String formattedForSender = ChatColor.GREEN + "You -> " + recipient.getName() + ": " + message;
        String formattedForRecipient = ChatColor.GREEN + sender.getName() + " -> You: " + message;
        
        // Send the messages
        sender.sendMessage(formattedForSender);
        recipient.sendMessage(formattedForRecipient);
        
        // Update last messaged tracking
        lastMessaged.put(senderUuid, recipientUuid);
        lastMessaged.put(recipientUuid, senderUuid);
        
        return true;
    }
    
    /**
     * Sends a message from the console to a player.
     *
     * @param recipient The recipient
     * @param message The message
     * @return true if the message was sent, false otherwise
     */
    public boolean sendConsoleMessage(Player recipient, String message) {
        if (recipient == null || !recipient.isOnline() || message == null || message.isEmpty()) {
            return false;
        }
        
        UUID recipientUuid = recipient.getUniqueId();
        
        // Format the message
        String formattedMessage = ChatColor.GREEN + "CONSOLE -> You: " + message;
        
        // Send the messages
        Bukkit.getConsoleSender().sendMessage(ChatColor.GREEN + "CONSOLE -> " + recipient.getName() + ": " + message);
        recipient.sendMessage(formattedMessage);
        
        // Update last messaged tracking for recipient
        lastMessaged.put(recipientUuid, null); // null indicates console
        
        return true;
    }
    
    /**
     * Filters a message, replacing any filtered words with the configured replacement.
     *
     * @param message The message to filter
     * @return The filtered message
     */
    private String filterMessage(String message) {
        if (!enableMessageFilter || filteredWords.isEmpty()) {
            return message;
        }
        
        String filteredMessage = message;
        
        for (String word : filteredWords) {
            // Create pattern that matches the word with word boundaries
            Pattern pattern = Pattern.compile("\\b" + Pattern.quote(word) + "\\b", Pattern.CASE_INSENSITIVE);
            Matcher matcher = pattern.matcher(filteredMessage);
            filteredMessage = matcher.replaceAll(messageFilterReplacement);
        }
        
        return filteredMessage;
    }
    
    /**
     * Formats a message using the given template.
     *
     * @param template The message template
     * @param sender The sender's name
     * @param recipient The recipient's name
     * @param message The message
     * @return The formatted message
     */
    private String formatMessage(String template, String sender, String recipient, String message) {
        return template.replace("{sender}", sender)
                      .replace("{recipient}", recipient)
                      .replace("{message}", message)
                      .replace("&", "§"); // Process color codes
    }
    
    /**
     * Gets the last player that another player messaged.
     *
     * @param player The player
     * @return The UUID of the last player messaged, or null if none
     */
    public UUID getLastMessaged(Player player) {
        if (player == null) {
            return null;
        }
        return lastMessaged.get(player.getUniqueId());
    }
    
    /**
     * Replies to the last player that messaged this player.
     *
     * @param sender The sender
     * @param message The message
     * @return true if the reply was sent, false otherwise
     */
    public boolean replyToLastMessage(Player sender, String message) {
        if (sender == null || message == null || message.isEmpty()) {
            return false;
        }
        
        UUID lastUUID = getLastMessaged(sender);
        if (lastUUID == null) {
            sender.sendMessage(ChatColor.RED + "You have nobody to reply to.");
            return false;
        }
        
        // If the last messaged was console
        if (lastUUID.toString().equals("00000000-0000-0000-0000-000000000000")) {
            Bukkit.getConsoleSender().sendMessage(ChatColor.GREEN + sender.getName() + " -> CONSOLE: " + message);
            sender.sendMessage(ChatColor.GREEN + "You -> CONSOLE: " + message);
            return true;
        }
        
        Player recipient = plugin.getServer().getPlayer(lastUUID);
        if (recipient == null || !recipient.isOnline()) {
            sender.sendMessage(ChatColor.RED + "The player you last messaged is offline.");
            return false;
        }
        
        return sendMessage(sender, recipient, message);
    }
    
    /**
     * Adds a player to another player's ignore list.
     *
     * @param player The player
     * @param ignored The player to ignore
     * @return true if the player was ignored, false if they were already ignored
     */
    public boolean ignorePlayer(Player player, Player ignored) {
        if (player == null || ignored == null) {
            return false;
        }
        
        UUID playerUuid = player.getUniqueId();
        UUID ignoredUuid = ignored.getUniqueId();
        
        // Don't allow ignoring yourself
        if (playerUuid.equals(ignoredUuid)) {
            player.sendMessage(ChatColor.RED + "You cannot ignore yourself.");
            return false;
        }
        
        Set<UUID> ignored_list = ignoredPlayers.computeIfAbsent(playerUuid, k -> new HashSet<>());
        
        if (ignored_list.contains(ignoredUuid)) {
            player.sendMessage(ChatColor.RED + "You are already ignoring " + ignored.getName() + ".");
            return false;
        }
        
        ignored_list.add(ignoredUuid);
        player.sendMessage(ChatColor.GREEN + "You are now ignoring " + ignored.getName() + ".");
        
        return true;
    }
    
    /**
     * Removes a player from another player's ignore list.
     *
     * @param player The player
     * @param ignored The player to unignore
     * @return true if the player was unignored, false if they weren't ignored
     */
    public boolean unignorePlayer(Player player, Player ignored) {
        if (player == null || ignored == null) {
            return false;
        }
        
        UUID playerUuid = player.getUniqueId();
        UUID ignoredUuid = ignored.getUniqueId();
        
        Set<UUID> ignored_list = ignoredPlayers.get(playerUuid);
        if (ignored_list == null || !ignored_list.contains(ignoredUuid)) {
            player.sendMessage(ChatColor.RED + "You are not ignoring " + ignored.getName() + ".");
            return false;
        }
        
        ignored_list.remove(ignoredUuid);
        if (ignored_list.isEmpty()) {
            ignoredPlayers.remove(playerUuid);
        }
        
        player.sendMessage(ChatColor.GREEN + "You are no longer ignoring " + ignored.getName() + ".");
        
        return true;
    }
    
    /**
     * Gets a list of players that are being ignored by a player.
     *
     * @param player The player
     * @return A list of ignored player names
     */
    public List<String> getIgnoredPlayers(Player player) {
        if (player == null) {
            return new ArrayList<>();
        }
        
        UUID playerUuid = player.getUniqueId();
        Set<UUID> ignored_list = ignoredPlayers.get(playerUuid);
        if (ignored_list == null || ignored_list.isEmpty()) {
            return new ArrayList<>();
        }
        
        List<String> ignoredNames = new ArrayList<>();
        for (UUID ignoredUuid : ignored_list) {
            String name = Bukkit.getOfflinePlayer(ignoredUuid).getName();
            if (name != null) {
                ignoredNames.add(name);
            }
        }
        
        return ignoredNames;
    }
    
    /**
     * Checks if a player is ignoring another player.
     *
     * @param playerUuid The player's UUID
     * @param targetUuid The target player's UUID
     * @return true if the player is ignoring the target, false otherwise
     */
    public boolean isIgnoring(UUID playerUuid, UUID targetUuid) {
        if (playerUuid == null || targetUuid == null) {
            return false;
        }
        
        Set<UUID> ignored_list = ignoredPlayers.get(playerUuid);
        return ignored_list != null && ignored_list.contains(targetUuid);
    }
    
    /**
     * Toggles social spy for a player.
     *
     * @param player The player
     * @return true if social spy was enabled, false if it was disabled
     */
    public boolean toggleSocialSpy(Player player) {
        if (player == null) {
            return false;
        }
        
        UUID playerUuid = player.getUniqueId();
        boolean enabled = !isSocialSpyEnabled(playerUuid);
        
        socialSpy.put(playerUuid, enabled);
        
        if (enabled) {
            player.sendMessage(ChatColor.GREEN + "Social spy enabled.");
        } else {
            player.sendMessage(ChatColor.RED + "Social spy disabled.");
        }
        
        return enabled;
    }
    
    /**
     * Checks if social spy is enabled for a player.
     *
     * @param playerUuid The player's UUID
     * @return true if social spy is enabled, false otherwise
     */
    public boolean isSocialSpyEnabled(UUID playerUuid) {
        if (playerUuid == null) {
            return false;
        }
        
        return socialSpy.getOrDefault(playerUuid, false);
    }
    
    /**
     * Toggles private messaging for a player.
     *
     * @param player The player
     * @return true if messaging was enabled, false if it was disabled
     */
    public boolean toggleMessaging(Player player) {
        if (player == null) {
            return false;
        }
        
        UUID playerUuid = player.getUniqueId();
        boolean disabled = messagingDisabled.contains(playerUuid);
        
        if (disabled) {
            messagingDisabled.remove(playerUuid);
            player.sendMessage(ChatColor.GREEN + "Private messaging enabled.");
            return true;
        } else {
            messagingDisabled.add(playerUuid);
            player.sendMessage(ChatColor.RED + "Private messaging disabled.");
            return false;
        }
    }
    
    /**
     * Checks if a player has disabled private messaging.
     *
     * @param playerUuid The player's UUID
     * @return true if messaging is disabled, false otherwise
     */
    public boolean hasMessagingDisabled(UUID playerUuid) {
        if (playerUuid == null) {
            return false;
        }
        
        return messagingDisabled.contains(playerUuid);
    }
    
    /**
     * Gets the message history for a player.
     *
     * @param player The player
     * @param count The number of messages to get (0 for all)
     * @return A list of formatted message history entries
     */
    public List<String> getMessageHistory(Player player, int count) {
        if (player == null || !enableMessageLogging) {
            return new ArrayList<>();
        }
        
        UUID playerUuid = player.getUniqueId();
        List<MessageEntry> history = messageHistory.get(playerUuid);
        if (history == null || history.isEmpty()) {
            return new ArrayList<>();
        }
        
        List<String> formattedHistory = new ArrayList<>();
        SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
        
        int startIndex = (count <= 0 || count >= history.size()) ? 0 : history.size() - count;
        for (int i = startIndex; i < history.size(); i++) {
            MessageEntry entry = history.get(i);
            
            String senderName = entry.getSenderUuid().equals(playerUuid) ? 
                    "You" : Bukkit.getOfflinePlayer(entry.getSenderUuid()).getName();
            String recipientName = entry.getRecipientUuid().equals(playerUuid) ? 
                    "You" : Bukkit.getOfflinePlayer(entry.getRecipientUuid()).getName();
            
            if (senderName == null) senderName = "Unknown";
            if (recipientName == null) recipientName = "Unknown";
            
            String timestamp = dateFormat.format(new Date(entry.getTimestamp()));
            
            String formatted = ChatColor.GRAY + "[" + timestamp + "] " + 
                    ChatColor.GREEN + senderName + ChatColor.GRAY + " → " + 
                    ChatColor.GREEN + recipientName + ChatColor.GRAY + ": " + 
                    ChatColor.WHITE + entry.getMessage();
            
            formattedHistory.add(formatted);
        }
        
        return formattedHistory;
    }
    
    /**
     * Clears the message history for a player.
     *
     * @param player The player
     * @return true if the history was cleared, false if there was no history
     */
    public boolean clearMessageHistory(Player player) {
        if (player == null || !enableMessageLogging) {
            return false;
        }
        
        UUID playerUuid = player.getUniqueId();
        if (!messageHistory.containsKey(playerUuid)) {
            return false;
        }
        
        messageHistory.remove(playerUuid);
        player.sendMessage(ChatColor.GREEN + "Your message history has been cleared.");
        
        return true;
    }
    
    /**
     * Internal class representing a message entry in the history.
     */
    private static class MessageEntry {
        private final UUID senderUuid;
        private final UUID recipientUuid;
        private final String message;
        private final long timestamp;
        
        /**
         * Creates a new MessageEntry.
         *
         * @param senderUuid The sender's UUID
         * @param recipientUuid The recipient's UUID
         * @param message The message
         * @param timestamp The timestamp
         */
        public MessageEntry(UUID senderUuid, UUID recipientUuid, String message, long timestamp) {
            this.senderUuid = senderUuid;
            this.recipientUuid = recipientUuid;
            this.message = message;
            this.timestamp = timestamp;
        }
        
        /**
         * Gets the sender's UUID.
         *
         * @return The sender's UUID
         */
        public UUID getSenderUuid() {
            return senderUuid;
        }
        
        /**
         * Gets the recipient's UUID.
         *
         * @return The recipient's UUID
         */
        public UUID getRecipientUuid() {
            return recipientUuid;
        }
        
        /**
         * Gets the message.
         *
         * @return The message
         */
        public String getMessage() {
            return message;
        }
        
        /**
         * Gets the timestamp.
         *
         * @return The timestamp
         */
        public long getTimestamp() {
            return timestamp;
        }
    }
}